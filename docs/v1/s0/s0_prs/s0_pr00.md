# agency slice 00 / pr-00: project skeleton + shared contracts

## goal
establish the go project scaffolding and the shared “public contract” primitives required for slice 00: command dispatch, stable error codes, stub-friendly interfaces for external commands + filesystem, and atomic json write helper.

## scope
in scope:
- go module + package layout
- cli dispatcher skeleton with subcommands `init` and `doctor` (can be stubbed / not implemented)
- stable error code system (type + formatting + wrapping)
- interfaces + real implementations:
  - `CommandRunner` for running external commands (git/tmux/gh) in later PRs
  - `FS` for filesystem reads/writes used by later PRs
- atomic file write helper for json persistence (temp file + rename)

out of scope (hard):
- any real `agency init` or `agency doctor` behavior
- any git repo discovery (`git rev-parse`) logic
- any `agency.json` parsing/validation
- any persistence beyond the atomic helper
- any worktrees, tmux session creation, scripts execution, or run meta/events files
- any network calls

## public surface area
commands must exist (help + parsing only):
- `agency init` (flags may exist but behavior can be “not implemented”)
- `agency doctor` (same)

`agency --help`, `agency init --help`, `agency doctor --help` must work.

## command + output behavior (v1 contract for pr-00)
- `agency` with no args prints usage and exits non-zero with a stable error code (pick one: `E_USAGE`).
- `agency init` and `agency doctor` may return `E_NOT_IMPLEMENTED` for now, but:
  - must print error output to stderr in the stable format (see below)
  - must exit non-zero
- stdout should be reserved for normal output; errors go to stderr.
- unknown subcommand prints usage and exits non-zero with `E_USAGE`
- `-h` / `--help` prints usage and exits 0

## error model (must be stable)
define:
- `type Code string`
- `type AgencyError struct { Code Code; Msg string; Cause error }`
- `func (e *AgencyError) Error() string` returns: `<CODE>: <Msg>`
- `func (e *AgencyError) Unwrap() error { return e.Cause }`
- `func Wrap(code Code, msg string, err error) error`
- `func New(code Code, msg string) error`
- `func ExitCode(err error) int` returns:
  - 0 if err == nil
  - 2 for `E_USAGE`
  - 1 for all other errors (v1 simple)
- printing rule (stderr):
  - first line: `error_code: <CODE>`
  - second line: `<message>`
  - if `--debug` later: stack/cause (NOT in v1)

required codes in pr-00:
- `E_USAGE`
- `E_NOT_IMPLEMENTED`
(add others later; do not prematurely enumerate slice-00’s full taxonomy here.)

## interfaces

### CommandRunner
must be stub-friendly and support capturing stdout/stderr and exit code.

recommended:
```go
type CmdResult struct {
  Stdout   string
  Stderr   string
  ExitCode int
}
type RunOpts struct {
  Dir string            // optional working dir
  Env map[string]string // optional extra env (overlay)
}
type CommandRunner interface {
  Run(ctx context.Context, name string, args []string, opts RunOpts) (CmdResult, error)
}

real impl:
	•	uses exec.CommandContext
	•	captures stdout/stderr buffers
	•	if process exits non-zero, return CmdResult{ExitCode: ...} and nil error
	•	return error only for execution failures (binary not found, ctx canceled/deadline, io failure)
	•	rationale: later code needs to branch on exit code without parsing error strings.

FS

keep minimal; only what pr-00 needs for atomic write test + later growth.

recommended initial:

type FS interface {
  MkdirAll(path string, perm os.FileMode) error
  ReadFile(path string) ([]byte, error)
  WriteFile(path string, data []byte, perm os.FileMode) error
  Stat(path string) (fs.FileInfo, error) // io/fs
  Rename(oldpath, newpath string) error
  Remove(path string) error
  Chmod(path string, perm os.FileMode) error
  CreateTemp(dir, pattern string) (string, io.WriteCloser, error)
}

real impl: thin wrappers over os / os.ReadFile / os.WriteFile.

atomic write helper

implement:
	•	WriteFileAtomic(fs FS, path string, data []byte, perm os.FileMode) error

requirements:
	•	writes to a temp file in the same directory as path (to make rename atomic on posix filesystems)
	•	temp file created via FS.CreateTemp
	•	ensures parent dir exists (caller responsibility in v1; do not mkdir automatically here)
	•	sets perm on final file
	•	does fs.Rename(tmp, path) (replace if exists; temp file must be in same dir)
	•	cleans up temp on error
	•	does not leave partial target file contents if crash happens mid-write (best-effort guarantee using rename semantics)

do not implement fsync in v1.

project structure (locked for slice 00)

create:
	•	cmd/agency/main.go (main entry)
	•	internal/cli/dispatch.go (arg parsing + dispatch)
	•	internal/errors/errors.go
	•	internal/exec/runner.go (interfaces + real runner)
	•	internal/fs/fs.go (interfaces + real fs)
	•	internal/fs/atomic.go

optional:
	•	internal/version/version.go with var Version = "dev" for future release builds (safe to include).

tests

unit tests (required)
	1.	atomic write:

	•	write initial file, then overwrite with new bytes via WriteFileAtomic
	•	assert file contents exactly new bytes
	•	assert no *.tmp left behind in dir (pattern match)
	•	simulate failure path:
	•	create FS stub that fails on Rename
	•	ensure target file is unchanged and temp is removed

	2.	error formatting stability:

	•	New(E_USAGE, "x").Error() must equal E_USAGE: x
	•	wrapping preserves code + message
	•	printing writes `error_code: E_USAGE` then `x` on stderr

test harness constraints
	•	tests must run via go test ./...
	•	do not require git/tmux/gh installed for tests

acceptance (manual)
	•	go test ./... passes
	•	go run ./cmd/agency --help prints usage
	•	go run ./cmd/agency init --help works
	•	go run ./cmd/agency doctor --help works
	•	go run ./cmd/agency init exits non-zero; stderr includes `error_code: E_NOT_IMPLEMENTED`
	•	go run ./cmd/agency exits non-zero; stderr includes `error_code: E_USAGE`
	•	go run ./cmd/agency nope exits non-zero with E_USAGE and prints usage
	•	go run ./cmd/agency -h exits 0

guardrails
	•	do not implement real slice-00 behaviors (repo discovery, validation, persistence)
	•	do not add third-party cli libraries (no cobra)
	•	keep interfaces minimal; don’t pre-build a framework
	•	keep stdout/stderr separation strict
	•	unknown subcommand returns E_USAGE and prints usage
	•	-h/--help returns 0

optional structure:
	•	internal/cli/dispatch.go returns error; main handles printing + exit
	•	internal/cli/usage.go holds usage text

### prompt pack to run pr-00
```bash
# from repo root
go test ./...
go run ./cmd/agency --help
go run ./cmd/agency init --help
go run ./cmd/agency doctor --help
go run ./cmd/agency init || true
go run ./cmd/agency || true
