# Slice 8 — PR-01: Integration Worktree Primitive + Store Support

## Purpose

Introduce **integration worktrees** as a first-class v2 primitive with durable on-disk state, discoverability, and safe lifecycle management.

This PR establishes the *stable, human-owned branches* that all future agent sandboxes will target — without introducing agents, sandboxes, or runners yet.

---

## Scope

### In-Scope

- New v2 **integration worktree** record + directory layout
- Store helpers for worktree discovery and mutation
- Worktree resolver (name / id / prefix)
- CLI commands:
  - `agency worktree create`
  - `agency worktree ls`
  - `agency worktree show`
  - `agency worktree path`
  - `agency worktree open`
  - `agency worktree shell`
  - `agency worktree rm`
- Enforcement of **integration tree invariant** via marker file

### Explicitly Out of Scope

- Agents, sandboxes, runners
- tmux, subprocess execution
- Landing / diff / checkpoints
- Watch UI
- Any changes to legacy v1 run behavior

---

## Invariants (Must Hold)

1. **Integration worktrees are human-owned.**
   No runner or automation executes inside them.
2. **Each integration worktree has a stable identity.**
   Identity persists even after archival.
3. **v2 integration worktrees MUST NOT share a directory namespace with v1 run worktrees.**
4. **All state is inspectable on disk.**
   No hidden global indexes.
5. **Operations are reversible.**
   Removal archives metadata; no silent deletion.

---

## On-Disk Layout (New)

To avoid collision with v1 `worktrees/`, v2 integration worktrees live under a **new root**:

```
${AGENCY_DATA_DIR}/repos/<repo_id>/integration_worktrees/<worktree_id>/
├── meta.json
└── tree/
    ├── .git
    ├── .agency/
    │   └── INTEGRATION_MARKER
    └── <project files>
```

### Rationale

- v1 uses `repos/<repo_id>/worktrees/<run_id>/` as *the tree itself*
- v2 requires a **record + tree split**
- Mixing both under `worktrees/` would create ambiguous semantics

---

## Integration Worktree Record

### `meta.json` Schema

```json
{
  "schema_version": "1.0",
  "worktree_id": "20260201123000-a3f2",
  "name": "my-feature",
  "repo_id": "abc123def456",
  "branch": "agency/my-feature-a3f2",
  "parent_branch": "main",
  "tree_path": "/abs/path/to/.../integration_worktrees/20260201123000-a3f2/tree",
  "created_at": "2026-02-01T12:30:00Z",
  "state": "present"
}
```

### Field Notes

| Field | Description |
|---|---|
| `worktree_id` | Generated via existing run ID generator (timestamp + 4 hex) |
| `name` | Unique among **non-archived** integration worktrees. Pattern: `[a-z0-9-]{2,40}` |
| `branch` | Format: `agency/<name>-<shortid>` |
| `state` | `present` \| `archived` |
| `tree_path` | Absolute path to `tree/` |

**Deferred to later PR:** `last_used_at` — update semantics are non-trivial (which commands count as "touch"?). Adding the field without consistent update rules causes drift. Will be introduced alongside the commands that use it.

---

## Integration Marker

On creation, write:

```
tree/.agency/INTEGRATION_MARKER
```

Contents may be empty or a short comment.

**Purpose:**

- Later PRs will hard-fail if a runner attempts to execute in a directory containing this marker.
- Marker presence is the canonical signal: "this is an integration tree".

---

## Store Additions

### New Path Helpers (on `*Store`)

| Method | Signature |
|---|---|
| `IntegrationWorktreesDir` | `(repoID string) string` |
| `IntegrationWorktreeDir` | `(repoID, worktreeID string) string` |
| `IntegrationWorktreeMetaPath` | `(repoID, worktreeID string) string` |
| `IntegrationWorktreeTreePath` | `(repoID, worktreeID string) string` |

### Directory Creation

- Parent dirs: `os.MkdirAll`
- Worktree dir: `os.Mkdir` (exclusive) to detect collisions
- Tree dir created implicitly by `git worktree add`

### Atomic Writes

- All `meta.json` writes via `fs.WriteJSONAtomic`
- No file-level locking beyond repo lock + atomic rename

---

## Scanning & Discovery

### Strategy

- No global index file
- Scan filesystem on demand

### Implementation

New scanner patterned after existing runs scanner:

- `ScanIntegrationWorktreesForRepo(dataDir, repoID)`
- Reads `integration_worktrees/*/meta.json`

Broken or unreadable meta:

- Mark record as `Broken: true`
- Exclude from name resolution and prefix resolution
- Still visible in `ls --all`
- Resolvable by exact ID (escape hatch)

### Broken Entry Output Contract

- `ls --all` includes broken entries with `status=broken` and `worktree_id` inferred from directory name
- `show` on a broken worktree: error with `E_STORE_CORRUPT`, but also print the record directory path and a hint ("meta.json is corrupt or unreadable; inspect or remove the directory manually")
- JSON output for broken entries includes `"broken": true` and `"worktree_id"` (from dir name) with all other fields omitted or null

### Sorting

- Stable sort by `created_at` ascending
- Secondary key: `worktree_id`

---

## Resolver

Reuse existing generic ID resolver (`internal/ids/resolve.go`).

### Resolution Rules

**By default, resolution excludes archived and broken worktrees.** This keeps the common case clean.

- **Name match:** resolves only `present` worktrees
- **ID / prefix match:** resolves only `present` worktrees by default
- **`--all` flag:** allows ID / prefix to also match `archived` worktrees
- **Exact ID:** always resolves, regardless of state (archived, broken) — this is the escape hatch so users are never locked out of a worktree they know the ID of
- Ambiguous prefix → error

This avoids "I know the ID but the tool says not found" situations while keeping default output uncluttered.

---

## CLI Commands

### `agency worktree create`

```
agency worktree create --name <name> [--parent <branch>] [--open]
```

#### Repo-Safety Gates

The following gates must pass before creation proceeds:

- CWD must be inside a git repository
- Parent working tree must be clean (no uncommitted changes)
- `agency.json` is **not** required — only agent operations require scripts/config

#### Behavior

1. Verify repo-safety gates (above)
2. Generate `worktree_id`
3. Create record dir: `os.Mkdir` (exclusive, detects collisions)
4. `git worktree add -b agency/<name>-<shortid> <tree_path> <parent>`
5. Write `.agency/INTEGRATION_MARKER`
6. Write `meta.json` (with `state: present`)
7. Open editor if `--open`

**Ordering rationale:** Marker must be written before `meta.json`. If marker write fails after meta exists, you have a "present" worktree that later PRs treat as safe to run agents in — violating the integration tree invariant.

#### Failure Cleanup Contract (Required)

`git worktree add` can produce partial state: a branch may be created, the worktree dir may exist on disk, and `.git/worktrees/*` entries may be registered — all before later steps fail.

On **any failure after `git worktree add` succeeds**, the following cleanup runs (all best-effort):

1. `git worktree remove --force <tree_path>` — remove the worktree registration and tree directory
2. `git branch -D <branch>` — remove the branch that was created for this worktree
3. Remove the record dir if `meta.json` was not successfully written

All cleanup steps are best-effort: errors are logged but do not mask the original failure. The original error surfaces to the user. The goal is to leave the repo in a recoverable state, not to guarantee perfect rollback.

---

### `agency worktree ls`

```
agency worktree ls [--all] [--json]
```

- Default: show `state == present`
- `--all`: include archived + broken
- No side effects

---

### `agency worktree show`

```
agency worktree show <name|id|prefix> [--json]
```

- Resolver-based lookup
- Human or JSON output

---

### `agency worktree path`

```
agency worktree path <name|id|prefix>
```

- Prints **only** absolute tree path
- No trailing newline decoration beyond `\n`

---

### `agency worktree open`

```
agency worktree open <name|id|prefix> [--editor <name>]
```

- Uses existing editor resolution
- CWD irrelevant

---

### `agency worktree shell`

```
agency worktree shell <name|id|prefix>
```

- Spawn `$SHELL -l` as a **child process** (not `exec`) with `cmd.Dir = tree_path`
- Inherits environment, stdin/stdout/stderr
- Exiting the shell returns control to agency

**Rationale:** `exec` replaces the agency process — the user would never return to agency after exiting the shell. Spawning a child via `exec.Command($SHELL, "-l")` with `cmd.Dir` set preserves the parent process.

---

### `agency worktree rm`

```
agency worktree rm <name|id|prefix> [--force]
```

**Behavior:**

1. Resolve worktree
2. `git worktree remove <tree_path>` (**no** `--force`)
3. If git remove fails due to dirty/untracked files: error `E_DIRTY_WORKTREE` with hint: "commit or stash your changes, or rerun with `--force`"
4. On success: set `state = archived` in `meta.json`
5. Preserve `meta.json` (record directory persists)
6. Tree directory removed by git

**`--force` flag:** Accepted in this PR as a simple override for human use. When passed, uses `git worktree remove --force <tree_path>`. This is safe because integration worktrees are human-owned — the human is explicitly choosing to discard their own uncommitted work.

**Rationale:** Default non-force preserves the "human-owned" story. Force-removing by default would silently drop uncommitted work in the integration tree, which violates the ownership contract.

---

## Locking Rules

- Repo lock held for:
  - create
  - rm
  - `meta.json` mutation
- Read-only commands are lock-free

---

## Tests (Required)

### Unit Tests

- **Resolver:**
  - Exact name
  - Exact ID
  - Unique prefix
  - Ambiguous prefix
  - Archived exclusion
- **Name uniqueness** enforcement

### Integration Tests (real git)

- `create` → tree exists → marker exists → meta.json valid
- `rm` → tree removed → meta archived → `E_DIRTY_WORKTREE` if dirty
- `rm --force` → tree removed even if dirty
- `path` / `open` / `shell` point to correct directory
- Failure during `create` leaves no tree behind

#### Failure Injection for Cleanup Test

"Failure during create leaves no tree behind" is hard to trigger deterministically without an injection point. Required approach:

- The worktree service `Create` function accepts a `CommandRunner` interface (already the pattern in the codebase)
- In tests, use a `fakeCommandRunner` that succeeds for `git worktree add` but returns an error for the next operation (marker write)
- Alternatively: make the record directory read-only after `git worktree add` so that marker/meta writes fail with a permission error
- After the expected failure, assert:
  - No worktree registered in `git worktree list`
  - Branch does not exist (`git branch --list <branch>`)
  - Record directory is cleaned up (or empty)

The test must specify the failure point — "something fails" is not testable.

---

## Acceptance Criteria

- [ ] Integration worktrees live under `integration_worktrees/`
- [ ] No v1 path collisions
- [ ] Marker always written
- [ ] Resolver behaves deterministically
- [ ] All commands work without agents present
- [ ] No changes to legacy v1 behavior

---

## Deferred (Intentionally)

- Agents
- Sandboxes
- Landing
- Watch
- Auto-rename
- `last_used_at` field and touch semantics

PR-01 establishes the **foundation**. Nothing more.
