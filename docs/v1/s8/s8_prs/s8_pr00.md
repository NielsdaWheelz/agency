# PR-00 — Cobra Migration + Command Skeletons

## Purpose

Replace the handwritten CLI dispatcher with **Cobra**, without changing command behavior, exit codes, or JSON output semantics.

This PR exists solely to unblock future subcommand expansion (`worktree`, `agent`, `watch`) with a maintainable command tree.

**This PR must not introduce any new product behavior.**

---

## Scope

### In Scope

* Introduce Cobra as the CLI framework
* Migrate **all** existing commands from `internal/cli/dispatch.go` to Cobra adapters
* Delete `internal/cli/dispatch.go` entirely
* Preserve all existing commands and flags as-is
* Register new command groups (`worktree`, `agent`, `watch`) as empty shells
* Replace handwritten completion scripts with Cobra-generated completion
* Rewrite completion tests to validate Cobra output behaviorally (no golden snapshots)

### Explicitly Out of Scope

* No new commands with logic
* No new storage paths
* No worktree / sandbox / agent behavior
* No refactors of `internal/commands/*` (business logic untouched)
* No semantic or lifecycle changes

---

## High-Level Design

### Architecture

```
cmd/agency/main.go
└── cobra root command (internal/cli/cobra/root.go)
    ├── init
    ├── doctor
    ├── run
    ├── ls
    ├── show
    ├── path
    ├── open
    ├── attach
    ├── resume
    ├── stop
    ├── kill
    ├── push
    ├── verify
    ├── merge
    ├── clean
    ├── resolve
    ├── version
    ├── completion  (cobra-generated)
    ├── worktree    (empty shell)
    ├── agent       (empty shell)
    └── watch       (empty shell)
```

**Business logic remains untouched.**
Every adapter calls the same `commands.Xxx(ctx, cr, fsys, cwd, opts, stdout, stderr)` signatures that exist today.

---

## File Layout

### New Directory

```
internal/cli/cobra/
├── root.go            # root command, global flags, error handling
├── completion.go      # agency completion bash|zsh via cobra generators
├── cmd_init.go
├── cmd_doctor.go
├── cmd_run.go
├── cmd_ls.go
├── cmd_show.go
├── cmd_path.go
├── cmd_open.go
├── cmd_attach.go
├── cmd_resume.go
├── cmd_stop.go
├── cmd_kill.go
├── cmd_push.go
├── cmd_verify.go
├── cmd_merge.go
├── cmd_clean.go
├── cmd_resolve.go
├── cmd_version.go
├── worktree.go        # empty shell
├── agent.go           # empty shell
└── watch.go           # empty shell
```

### Deleted Files

* `internal/cli/dispatch.go` — replaced entirely by Cobra command tree
* `internal/commands/completion.go` — handwritten bash/zsh scripts replaced by Cobra generators
* `internal/cli/dispatch_test.go` — `reorderFlagsBeforeArgs` tests, help substring tests (rewritten)

### Preserved Files

* `internal/commands/*.go` — all business logic untouched
* `internal/errors/*` — error formatting and exit code mapping untouched
* `cmd/agency/main.go` — updated to call cobra root instead of `cli.Run()`

---

## Command Implementation Pattern

Each Cobra adapter follows this structure:

```go
func newShowCmd() *cobra.Command {
    var jsonOutput, pathOutput, capture bool

    cmd := &cobra.Command{
        Use:   "show <run_id>",
        Short: "Show details of a run",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            stdout := cmd.OutOrStdout()
            stderr := cmd.ErrOrStderr()

            cwd, err := os.Getwd()
            if err != nil {
                return errors.Wrap(errors.EInternal, "failed to get working directory", err)
            }

            cr := exec.NewRealRunner()
            fsys := fs.NewRealFS()

            opts := commands.ShowOpts{
                RunID:   args[0],
                JSON:    jsonOutput,
                Path:    pathOutput,
                Capture: capture,
                Args:    args,
            }

            return commands.Show(cmd.Context(), cr, fsys, cwd, opts, stdout, stderr)
        },
    }

    cmd.Flags().BoolVar(&jsonOutput, "json", false, "output as JSON")
    cmd.Flags().BoolVar(&pathOutput, "path", false, "output only resolved paths")
    cmd.Flags().BoolVar(&capture, "capture", false, "capture tmux scrollback")

    return cmd
}
```

Key invariants:

* **stdout/stderr** come from `cmd.OutOrStdout()` / `cmd.ErrOrStderr()`, never from `os.Stdout` / `os.Stderr` directly. These are passed through to `internal/commands` functions.
* **Context** comes from `cmd.Context()` (Cobra propagates the root context).
* **Dependencies** (`cr`, `fsys`, `cwd`) are created inside `RunE` — same as today.
* **No logic moves out of `internal/commands`.**
* **`reorderFlagsBeforeArgs` is deleted** — Cobra handles flag position natively.

---

## Error Handling Contract

### Requirements

* Preserve **exact exit code semantics**:

  * `nil` → exit 0
  * `E_USAGE` → exit 2
  * everything else → exit 1
* Preserve structured error formatting (`errors.PrintWithOptions`)
* No raw Go error output
* No stack traces

### Cobra Configuration

```go
rootCmd := &cobra.Command{
    Use:           "agency",
    SilenceErrors: true,
    SilenceUsage:  true,
}
```

* `SilenceErrors = true` — Cobra does not print errors; `main.go` handles all error output via `errors.PrintWithOptions`.
* `SilenceUsage = true` — Cobra does not auto-print usage on error.

### E_USAGE Policy

When a command returns `E_USAGE`:

1. The command's `RunE` prints the command's help/usage to stderr via `cmd.ErrOrStderr()` before returning the error.
2. `main.go` prints the structured error via `errors.PrintWithOptions` (which includes `error_code: E_USAGE`).
3. Process exits with code 2.

For all other errors: no usage text is printed. Only the structured error output appears.

### main.go

```go
func main() {
    root := cobra.NewRootCmd()
    err := root.Execute()
    if err != nil {
        opts := errors.PrintOptions{
            Verbose: /* extract from root persistent flag */,
        }
        errors.PrintWithOptions(os.Stderr, err, opts)
        os.Exit(errors.ExitCode(err))
    }
}
```

`main.go` remains the single exit point. Same pattern as today, just calling `root.Execute()` instead of `cli.Run()`.

---

## JSON Output Contract

### Invariants

* `ls --json` output schema **unchanged**
* `show --json` output schema **unchanged**
* `schema_version: "1.0"` preserved
* Formatting via `json.Encoder.SetIndent("", "  ")` preserved
* Tests continue to unmarshal and field-assert (no golden tests)

### Validation

All JSON tests must pass **without modification**. These tests live in `internal/commands/` and call business logic directly — they are unaffected by the Cobra migration.

---

## Flag Semantics

### Requirements

* All existing flags preserved (names, defaults, behavior)
* Positional arguments behave identically
* Flags may appear **before or after** positional args (Cobra handles this natively)
* Legacy `reorderFlagsBeforeArgs` is **deleted** — no longer needed

---

## Completion Migration

### What Changes

Completion behavior **changes** in this PR. The handwritten bash/zsh scripts are replaced with Cobra-generated scripts. Dynamic completion candidates (run names, runner names) are **not preserved** in this PR — they will be re-added in later PRs via Cobra's `ValidArgsFunction` and `RegisterFlagCompletionFunc`.

### Removed

* `internal/commands/completion.go` — handwritten bash/zsh template scripts
* Hidden `__complete` command
* `completeRuns()`, `completeRunners()`, `completeMergeStrategies()` — dynamic candidate functions (to be re-added later via Cobra APIs)

### Added

* `completion` command implemented as a custom Cobra command that calls:
  * `rootCmd.GenBashCompletion(w)` for `agency completion bash`
  * `rootCmd.GenZshCompletion(w)` for `agency completion zsh`
* Command name remains `agency completion` (backward compatible)
* Cobra's default `completion` command is **disabled** (`rootCmd.CompletionOptions.DisableDefaultCmd = true`) — we register our own with the same name for control over behavior and help text.

### Dynamic Completion (Deferred)

Dynamic completion for run names, runner names, and merge strategies is **not implemented** in PR-00. Static subcommand/flag completion works via Cobra out of the box. Dynamic candidates will be added in later PRs using:

* `ValidArgsFunction` on commands that take a `<run_id>` positional arg
* `RegisterFlagCompletionFunc` for `--runner`, etc.

---

## New Command Skeletons (No Logic)

These parent commands exist but have no subcommands yet:

```
agency worktree
agency agent
agency watch
```

### Implementation

```go
func newWorktreeCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "worktree",
        Short: "Manage integration worktrees",
        Args:  cobra.NoArgs,
        RunE: func(cmd *cobra.Command, args []string) error {
            cmd.Help()
            return errors.New(errors.EUsage, "specify a subcommand: agency worktree <create|ls|show|rm|...>")
        },
    }
    return cmd
}
```

Requirements:

* Appear in `agency help` output
* Return `E_USAGE` with a hint message when invoked without subcommands — **these are not placeholders that silently show help and exit 0**
* `cmd.Help()` prints usage to stderr first, then the error flows through `main.go` for structured output + exit 2
* No flags, no side effects

---

## Root Command + Version

### Help

Both `agency help` and `agency --help` must work and show the full command tree. Cobra provides this by default.

`agency -h` is an alias for `--help` (Cobra default behavior).

### Version

`agency version` remains a subcommand (not `--version` on root). Implementation:

```go
func newVersionCmd() *cobra.Command {
    return &cobra.Command{
        Use:   "version",
        Short: "Print agency version",
        Args:  cobra.NoArgs,
        Run: func(cmd *cobra.Command, args []string) {
            fmt.Fprintf(cmd.OutOrStdout(), "agency %s\n", version.FullVersion())
        },
    }
}
```

`agency -v` / `agency --version` on the root command: preserve existing behavior by checking `rootCmd.PersistentPreRunE` or by setting `rootCmd.Version` (Cobra prints `agency version <v>` on `--version`). Decide at implementation time which is cleaner — either approach is acceptable as long as the output format is `agency <version>\n`.

### Cobra Auto-Added Commands

Cobra auto-adds a `help` command. This is fine — it matches existing `agency help` behavior.

Cobra's default `completion` command is **disabled** (we register our own).

---

## Tests

### JSON Tests (Unchanged)

All tests in `internal/commands/ls_test.go` and `internal/commands/show_test.go` that unmarshal JSON and assert fields pass **without modification**. These test business logic, not CLI wiring.

### Help Text Tests (Rewritten)

Tests in `internal/cli/dispatch_test.go` that assert help output (e.g., `strings.Contains(stdout, "usage:")`) are rewritten to target **stable substrings** that survive Cobra's formatting:

* Command names (e.g., `"run"`, `"ls"`, `"show"`)
* Key flag names (e.g., `"--name"`, `"--runner"`, `"--json"`)
* Do NOT assert exact formatting, line counts, or whitespace

### Completion Tests (Rewritten)

The handwritten completion tests (`internal/commands/completion_test.go`) are replaced with minimal behavioral tests:

* `agency completion bash` output contains `_agency` (the completion function name)
* `agency completion zsh` output contains `#compdef agency`
* `agency completion invalid-shell` returns an error
* Do NOT golden-snapshot the full script (Cobra's output is version-dependent)

Dynamic completion tests (run candidates, runner candidates, merge strategies) are **removed** — the underlying functions are deleted in this PR. They will be re-added when dynamic completion is implemented via Cobra APIs.

### Behavior Tests (Unchanged)

All tests that assert on command semantics (exit codes, error codes, side effects) pass unchanged. These call `internal/commands` functions directly and are unaffected by the CLI layer swap.

---

## Acceptance Criteria

### Automated

* [ ] `go test ./...` passes
* [ ] All JSON output tests pass without modification
* [ ] All behavior tests pass without modification
* [ ] Help text tests pass (rewritten for stable substrings)
* [ ] Completion tests pass (rewritten for behavioral checks)
* [ ] No references to `dispatch.go`, `__complete`, or handwritten completion scripts remain
* [ ] `reorderFlagsBeforeArgs` deleted

### Manual Smoke Tests

Before merge, verify manually:

* [ ] `go run ./cmd/agency --help` — shows full command tree with all legacy commands + worktree/agent/watch
* [ ] `go run ./cmd/agency version` — prints version
* [ ] `go run ./cmd/agency ls --json` — unchanged JSON output (in a repo with runs)
* [ ] `go run ./cmd/agency show <run_id> --json` — unchanged JSON output
* [ ] `go run ./cmd/agency completion bash | head` — produces bash completion script
* [ ] `go run ./cmd/agency completion zsh | head` — produces zsh completion script
* [ ] `go run ./cmd/agency worktree` — returns exit 2, prints hint
* [ ] `go run ./cmd/agency agent` — returns exit 2, prints hint
* [ ] `go run ./cmd/agency run --name test --detached` — works end-to-end (if test environment available)

### Invariants

* [ ] All legacy commands work exactly as before (same flags, same behavior, same exit codes)
* [ ] Exit codes unchanged (0/1/2 mapping preserved)
* [ ] JSON output unchanged (`ls --json`, `show --json`)
* [ ] Empty `worktree`, `agent`, `watch` commands exist and error with `E_USAGE` + hint

---

## What Changes for Users

| Aspect | Before | After |
|---|---|---|
| Help formatting | Handwritten usage text | Cobra-generated (different layout) |
| Completion scripts | Handwritten bash/zsh with dynamic candidates | Cobra-generated, static only (dynamic added later) |
| `agency worktree` | Unknown command | Exists, returns E_USAGE with hint |
| `agency agent` | Unknown command | Exists, returns E_USAGE with hint |
| `agency watch` | Unknown command | Exists, returns E_USAGE with hint |
| Command behavior | Unchanged | Unchanged |
| Flag behavior | Unchanged | Unchanged |
| Exit codes | Unchanged | Unchanged |
| JSON output | Unchanged | Unchanged |

---

## Rollback Plan

If PR-00 causes instability:

* Revert entire PR
* No data migration required
* No on-disk format changes

---

## Definition of Done

PR-00 is done when:

* `dispatch.go` is deleted
* All commands are registered via Cobra
* Nothing user-visible changes except help/completion formatting
* Future PRs can add subcommands without touching CLI plumbing again
